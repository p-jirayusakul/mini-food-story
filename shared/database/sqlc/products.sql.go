// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO public.products
(id, "name", name_en, categories, description, price, is_available, image_url)
VALUES($1, $2, $3, $4, $5, $6, $7, $8 )
RETURNING id
`

type CreateProductParams struct {
	ID          int64          `json:"id"`
	Name        string         `json:"name"`
	NameEn      string         `json:"name_en"`
	Categories  int64          `json:"categories"`
	Description pgtype.Text    `json:"description"`
	Price       pgtype.Numeric `json:"price"`
	IsAvailable bool           `json:"is_available"`
	ImageUrl    pgtype.Text    `json:"image_url"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int64, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.NameEn,
		arg.Categories,
		arg.Description,
		arg.Price,
		arg.IsAvailable,
		arg.ImageUrl,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProductAvailableByID = `-- name: GetProductAvailableByID :one
SELECT p.id,
       p."name",
       p.name_en,
       p.categories,
       c.name as "categoryName",
       c.name_en as "categoryNameEN",
       p.description,
       p.price,
       p.is_available,
       p.image_url
FROM public.products as p
         INNER JOIN public.md_categories as c ON c.id = p.categories
WHERE p.id = $1::bigint AND p.is_available IS TRUE LIMIT 1
`

type GetProductAvailableByIDRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	NameEn         string         `json:"name_en"`
	Categories     int64          `json:"categories"`
	CategoryName   string         `json:"categoryName"`
	CategoryNameEN string         `json:"categoryNameEN"`
	Description    pgtype.Text    `json:"description"`
	Price          pgtype.Numeric `json:"price"`
	IsAvailable    bool           `json:"is_available"`
	ImageUrl       pgtype.Text    `json:"image_url"`
}

func (q *Queries) GetProductAvailableByID(ctx context.Context, id int64) (*GetProductAvailableByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductAvailableByID, id)
	var i GetProductAvailableByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NameEn,
		&i.Categories,
		&i.CategoryName,
		&i.CategoryNameEN,
		&i.Description,
		&i.Price,
		&i.IsAvailable,
		&i.ImageUrl,
	)
	return &i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT p.id,
       p."name",
       p.name_en,
       p.categories,
       c.name as "categoryName",
       c.name_en as "categoryNameEN",
       p.description,
       p.price,
       p.is_available,
       p.image_url
FROM public.products as p
         INNER JOIN public.md_categories as c ON c.id = p.categories
WHERE p.id = $1::bigint LIMIT 1
`

type GetProductByIDRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	NameEn         string         `json:"name_en"`
	Categories     int64          `json:"categories"`
	CategoryName   string         `json:"categoryName"`
	CategoryNameEN string         `json:"categoryNameEN"`
	Description    pgtype.Text    `json:"description"`
	Price          pgtype.Numeric `json:"price"`
	IsAvailable    bool           `json:"is_available"`
	ImageUrl       pgtype.Text    `json:"image_url"`
}

func (q *Queries) GetProductByID(ctx context.Context, id int64) (*GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NameEn,
		&i.Categories,
		&i.CategoryName,
		&i.CategoryNameEN,
		&i.Description,
		&i.Price,
		&i.IsAvailable,
		&i.ImageUrl,
	)
	return &i, err
}

const getTotalPageSearchProducts = `-- name: GetTotalPageSearchProducts :one
SELECT COUNT(*)
FROM public.products as p
         INNER JOIN public.md_categories as c ON c.id = p.categories
WHERE (($1::varchar IS NULL OR p."name" ILIKE '%' || $1::varchar || '%') OR ($1::varchar IS NULL OR p.name_en ILIKE '%' || $1::varchar || '%'))
  AND ($2::boolean IS NULL OR p.is_available = $2::boolean)
  AND (
    $3::bigint[] IS NULL
        OR array_length($3::bigint[], 1) = 0
        OR p.categories = ANY ($3::bigint[])
    )
`

type GetTotalPageSearchProductsParams struct {
	Name        pgtype.Text `json:"name"`
	IsAvailable pgtype.Bool `json:"is_available"`
	CategoryID  []int64     `json:"category_id"`
}

func (q *Queries) GetTotalPageSearchProducts(ctx context.Context, arg GetTotalPageSearchProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalPageSearchProducts, arg.Name, arg.IsAvailable, arg.CategoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isProductExists = `-- name: IsProductExists :one
SELECT count(*) > 0 as "isExists" FROM public.products WHERE id = $1
`

func (q *Queries) IsProductExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, isProductExists, id)
	var isExists bool
	err := row.Scan(&isExists)
	return isExists, err
}

const searchProducts = `-- name: SearchProducts :many
SELECT p.id,
       p."name",
       p.name_en,
       p.categories,
       c.name as "categoryName",
       c.name_en as "categoryNameEN",
       p.description,
       p.price,
       p.is_available,
       p.image_url
FROM public.products as p
         INNER JOIN public.md_categories as c ON c.id = p.categories
WHERE (($1::varchar IS NULL OR p."name" ILIKE '%' || $1::varchar || '%') OR ($1::varchar IS NULL OR p.name_en ILIKE '%' || $1::varchar || '%'))
  AND ($2::boolean IS NULL OR p.is_available = $2::boolean)
  AND (
    $3::bigint[] IS NULL
        OR array_length($3::bigint[], 1) = 0
        OR p.categories = ANY ($3::bigint[])
    )
ORDER BY CASE
             WHEN $4::text = 'asc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN p.id::text
                     WHEN $5::text = 'name' THEN p."name"
                     WHEN $5::text = 'price' THEN p.price::text
                     ELSE c.sort_order::text
                     END
             END,
         CASE
             WHEN $4::text = 'desc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN p.id::text
                     WHEN $5::text = 'name' THEN p."name"
                     WHEN $5::text = 'price' THEN p.price::text
                     ELSE c.sort_order::text
                     END
             END DESC
OFFSET $6 LIMIT $7
`

type SearchProductsParams struct {
	Name        pgtype.Text `json:"name"`
	IsAvailable pgtype.Bool `json:"is_available"`
	CategoryID  []int64     `json:"category_id"`
	OrderByType string      `json:"order_by_type"`
	OrderBy     string      `json:"order_by"`
	PageNumber  int64       `json:"page_number"`
	PageSize    int64       `json:"page_size"`
}

type SearchProductsRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	NameEn         string         `json:"name_en"`
	Categories     int64          `json:"categories"`
	CategoryName   string         `json:"categoryName"`
	CategoryNameEN string         `json:"categoryNameEN"`
	Description    pgtype.Text    `json:"description"`
	Price          pgtype.Numeric `json:"price"`
	IsAvailable    bool           `json:"is_available"`
	ImageUrl       pgtype.Text    `json:"image_url"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]*SearchProductsRow, error) {
	rows, err := q.db.Query(ctx, searchProducts,
		arg.Name,
		arg.IsAvailable,
		arg.CategoryID,
		arg.OrderByType,
		arg.OrderBy,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchProductsRow{}
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NameEn,
			&i.Categories,
			&i.CategoryName,
			&i.CategoryNameEN,
			&i.Description,
			&i.Price,
			&i.IsAvailable,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE public.products
SET "name"       = $2,
    name_en      = $3,
    categories   = $4,
    description  = $5,
    price        = $6,
    is_available = $7,
    image_url    = $8,
    updated_at   = NOW()
WHERE id = $1
`

type UpdateProductParams struct {
	ID          int64          `json:"id"`
	Name        string         `json:"name"`
	NameEn      string         `json:"name_en"`
	Categories  int64          `json:"categories"`
	Description pgtype.Text    `json:"description"`
	Price       pgtype.Numeric `json:"price"`
	IsAvailable bool           `json:"is_available"`
	ImageUrl    pgtype.Text    `json:"image_url"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.NameEn,
		arg.Categories,
		arg.Description,
		arg.Price,
		arg.IsAvailable,
		arg.ImageUrl,
	)
	return err
}

const updateProductAvailability = `-- name: UpdateProductAvailability :exec
UPDATE public.products
SET is_available = $2,
    updated_at   = NOW()
WHERE id = $1
`

type UpdateProductAvailabilityParams struct {
	ID          int64 `json:"id"`
	IsAvailable bool  `json:"is_available"`
}

func (q *Queries) UpdateProductAvailability(ctx context.Context, arg UpdateProductAvailabilityParams) error {
	_, err := q.db.Exec(ctx, updateProductAvailability, arg.ID, arg.IsAvailable)
	return err
}
