// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tables.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTable = `-- name: CreateTable :one
INSERT INTO public.tables(id, table_number, status_id, seats)
VALUES ($1, $2, (SELECT id FROM public.md_table_statuses WHERE code = 'DISABLED'), $3)
RETURNING id
`

type CreateTableParams struct {
	ID          int64 `json:"id"`
	TableNumber int32 `json:"table_number"`
	Seats       int32 `json:"seats"`
}

func (q *Queries) CreateTable(ctx context.Context, arg CreateTableParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTable, arg.ID, arg.TableNumber, arg.Seats)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTableNumber = `-- name: GetTableNumber :one
SELECT table_number as "tableNumber" FROM public.tables WHERE id = $1
`

func (q *Queries) GetTableNumber(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, getTableNumber, id)
	var tableNumber int32
	err := row.Scan(&tableNumber)
	return tableNumber, err
}

const getTotalPageQuickSearchTables = `-- name: GetTotalPageQuickSearchTables :one
SELECT COUNT(*) as "totalItems"
FROM public.tables t
         INNER JOIN public.md_table_statuses s ON t.status_id = s.id
WHERE t.seats >= $1::integer AND s.code = 'AVAILABLE'
`

func (q *Queries) GetTotalPageQuickSearchTables(ctx context.Context, numberOfPeople int32) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalPageQuickSearchTables, numberOfPeople)
	var totalItems int64
	err := row.Scan(&totalItems)
	return totalItems, err
}

const getTotalPageSearchTables = `-- name: GetTotalPageSearchTables :one
SELECT COUNT(*)
FROM public.tables t
         INNER JOIN public.md_table_statuses s ON t.status_id = s.id
WHERE ($1::int IS NULL OR t.table_number = $1::int)
  AND ($2::int IS NULL OR t.seats = $2::int)
  AND (
    $3::varchar[] IS NULL
        OR array_length($3::varchar[], 1) = 0
        OR s.code = ANY ($3::varchar[])
    )
`

type GetTotalPageSearchTablesParams struct {
	TableNumber pgtype.Int4 `json:"table_number"`
	Seats       pgtype.Int4 `json:"seats"`
	StatusCode  []string    `json:"status_code"`
}

func (q *Queries) GetTotalPageSearchTables(ctx context.Context, arg GetTotalPageSearchTablesParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalPageSearchTables, arg.TableNumber, arg.Seats, arg.StatusCode)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isTableAvailableOrReserved = `-- name: IsTableAvailableOrReserved :one
SELECT COUNT(id) > 0 as "isAvailable" FROM public.tables WHERE id = $1::bigint
AND (status_id = (select id from public.md_table_statuses WHERE code = 'AVAILABLE') OR status_id = (select id from public.md_table_statuses WHERE code = 'RESERVED'))
`

func (q *Queries) IsTableAvailableOrReserved(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, isTableAvailableOrReserved, id)
	var isAvailable bool
	err := row.Scan(&isAvailable)
	return isAvailable, err
}

const isTableExists = `-- name: IsTableExists :one
SELECT COUNT(id) > 0 as "isExists" FROM public.tables WHERE id = $1
`

func (q *Queries) IsTableExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, isTableExists, id)
	var isExists bool
	err := row.Scan(&isExists)
	return isExists, err
}

const quickSearchTables = `-- name: QuickSearchTables :many
SELECT t.id, t.table_number as "tableNumber", s.name as status, s.name_en as "statusEN", t.seats
FROM public.tables t
         INNER JOIN public.md_table_statuses s ON t.status_id = s.id
WHERE t.seats >= $1::integer AND s.code = 'AVAILABLE'
ORDER BY CASE
             WHEN $2::text = 'asc' THEN
                 CASE
                     WHEN $3::text = 'id' THEN t.id::text
                     WHEN $3::text = 'tableNumber' THEN t.table_number::text
                     WHEN $3::text = 'seats' THEN t.seats::text
                     WHEN $3::text = 'status' THEN t.status_id::text
                     ELSE t.table_number::text
                     END
             END,
         CASE
             WHEN $2::text = 'desc' THEN
                 CASE
                     WHEN $3::text = 'id' THEN t.id::text
                     WHEN $3::text = 'tableNumber' THEN t.table_number::text
                     WHEN $3::text = 'seats' THEN t.seats::text
                     WHEN $3::text = 'status' THEN t.status_id::text
                     ELSE t.table_number::text
                     END
             END DESC
OFFSET $4 LIMIT $5
`

type QuickSearchTablesParams struct {
	NumberOfPeople int32  `json:"number_of_people"`
	OrderByType    string `json:"order_by_type"`
	OrderBy        string `json:"order_by"`
	PageNumber     int64  `json:"page_number"`
	PageSize       int64  `json:"page_size"`
}

type QuickSearchTablesRow struct {
	ID          int64  `json:"id"`
	TableNumber int32  `json:"tableNumber"`
	Status      string `json:"status"`
	StatusEN    string `json:"statusEN"`
	Seats       int32  `json:"seats"`
}

func (q *Queries) QuickSearchTables(ctx context.Context, arg QuickSearchTablesParams) ([]*QuickSearchTablesRow, error) {
	rows, err := q.db.Query(ctx, quickSearchTables,
		arg.NumberOfPeople,
		arg.OrderByType,
		arg.OrderBy,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QuickSearchTablesRow{}
	for rows.Next() {
		var i QuickSearchTablesRow
		if err := rows.Scan(
			&i.ID,
			&i.TableNumber,
			&i.Status,
			&i.StatusEN,
			&i.Seats,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTables = `-- name: SearchTables :many
SELECT t.id, t.table_number as "tableNumber", s.name as status, s.name_en as "statusEN", t.seats
FROM public.tables t
         INNER JOIN public.md_table_statuses s ON t.status_id = s.id
WHERE ($1::int IS NULL OR t.table_number = $1::int)
  AND ($2::int IS NULL OR t.seats = $2::int)
  AND (
        $3::varchar[] IS NULL
        OR array_length($3::varchar[], 1) = 0
        OR s.code = ANY ($3::varchar[])
    )
ORDER BY CASE
             WHEN $4::text = 'asc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN t.id::text
                     WHEN $5::text = 'tableNumber' THEN t.table_number::text
                     WHEN $5::text = 'seats' THEN t.seats::text
                     WHEN $5::text = 'status' THEN t.status_id::text
                     ELSE t.table_number::text
                     END
             END,
         CASE
             WHEN $4::text = 'desc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN t.id::text
                     WHEN $5::text = 'tableNumber' THEN t.table_number::text
                     WHEN $5::text = 'seats' THEN t.seats::text
                     WHEN $5::text = 'status' THEN t.status_id::text
                     ELSE t.table_number::text
                     END
             END DESC
OFFSET $6 LIMIT $7
`

type SearchTablesParams struct {
	TableNumber pgtype.Int4 `json:"table_number"`
	Seats       pgtype.Int4 `json:"seats"`
	StatusCode  []string    `json:"status_code"`
	OrderByType string      `json:"order_by_type"`
	OrderBy     string      `json:"order_by"`
	PageNumber  int64       `json:"page_number"`
	PageSize    int64       `json:"page_size"`
}

type SearchTablesRow struct {
	ID          int64  `json:"id"`
	TableNumber int32  `json:"tableNumber"`
	Status      string `json:"status"`
	StatusEN    string `json:"statusEN"`
	Seats       int32  `json:"seats"`
}

func (q *Queries) SearchTables(ctx context.Context, arg SearchTablesParams) ([]*SearchTablesRow, error) {
	rows, err := q.db.Query(ctx, searchTables,
		arg.TableNumber,
		arg.Seats,
		arg.StatusCode,
		arg.OrderByType,
		arg.OrderBy,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchTablesRow{}
	for rows.Next() {
		var i SearchTablesRow
		if err := rows.Scan(
			&i.ID,
			&i.TableNumber,
			&i.Status,
			&i.StatusEN,
			&i.Seats,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTables = `-- name: UpdateTables :exec
UPDATE public.tables
SET table_number=$2, seats=$3, updated_at = NOW()
WHERE id=$1
`

type UpdateTablesParams struct {
	ID          int64 `json:"id"`
	TableNumber int32 `json:"table_number"`
	Seats       int32 `json:"seats"`
}

func (q *Queries) UpdateTables(ctx context.Context, arg UpdateTablesParams) error {
	_, err := q.db.Exec(ctx, updateTables, arg.ID, arg.TableNumber, arg.Seats)
	return err
}

const updateTablesStatus = `-- name: UpdateTablesStatus :exec
UPDATE public.tables
SET status_id=$2, updated_at = NOW()
WHERE id=$1
`

type UpdateTablesStatusParams struct {
	ID       int64 `json:"id"`
	StatusID int64 `json:"status_id"`
}

func (q *Queries) UpdateTablesStatus(ctx context.Context, arg UpdateTablesStatusParams) error {
	_, err := q.db.Exec(ctx, updateTablesStatus, arg.ID, arg.StatusID)
	return err
}

const updateTablesStatusAvailable = `-- name: UpdateTablesStatusAvailable :exec
UPDATE public.tables
SET status_id=(select id from public.md_table_statuses WHERE code = 'AVAILABLE'), updated_at = NOW()
WHERE id=$1::bigint
`

func (q *Queries) UpdateTablesStatusAvailable(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateTablesStatusAvailable, id)
	return err
}

const updateTablesStatusDisabled = `-- name: UpdateTablesStatusDisabled :exec
UPDATE public.tables
SET status_id=(select id from public.md_table_statuses WHERE code = 'DISABLED'), updated_at = NOW()
WHERE id=$1::bigint
`

func (q *Queries) UpdateTablesStatusDisabled(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateTablesStatusDisabled, id)
	return err
}

const updateTablesStatusOccupied = `-- name: UpdateTablesStatusOccupied :exec
UPDATE public.tables
SET status_id=(select id from public.md_table_statuses WHERE code = 'OCCUPIED'), updated_at = NOW()
WHERE id=$1::bigint
`

func (q *Queries) UpdateTablesStatusOccupied(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateTablesStatusOccupied, id)
	return err
}

const updateTablesStatusOrdered = `-- name: UpdateTablesStatusOrdered :exec
UPDATE public.tables
SET status_id=(select id from public.md_table_statuses WHERE code = 'ORDERED'), updated_at = NOW()
WHERE id=$1::bigint
`

func (q *Queries) UpdateTablesStatusOrdered(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateTablesStatusOrdered, id)
	return err
}

const updateTablesStatusReserved = `-- name: UpdateTablesStatusReserved :exec
UPDATE public.tables
SET status_id=(select id from public.md_table_statuses WHERE code = 'RESERVED'), updated_at = NOW()
WHERE id=$1::bigint
`

func (q *Queries) UpdateTablesStatusReserved(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateTablesStatusReserved, id)
	return err
}
