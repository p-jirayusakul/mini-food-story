// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO public.orders
(id, order_number, session_id, table_id, status_id)
VALUES($1::bigint, $2::varchar, $3::uuid, $4::bigint, (SELECT id FROM public.md_order_statuses WHERE code = 'CONFIRMED' LIMIT 1))
RETURNING id
`

type CreateOrderParams struct {
	ID          int64       `json:"id"`
	OrderNumber string      `json:"order_number"`
	SessionID   pgtype.UUID `json:"session_id"`
	TableID     int64       `json:"table_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.OrderNumber,
		arg.SessionID,
		arg.TableID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT o.id, o.session_id as "sessionID", o.table_id as "tableID", t.table_number as "tableNumber", o.status_id as "statusID", mos.name as "statusName", mos.name_en as "statusNameEN", mos.code as "statusCode"
FROM public.orders as o
JOIN public.md_order_statuses as mos ON o.status_id = mos.id
JOIN public.tables as t ON o.table_id = t.id
WHERE o.id = $1::bigint
`

type GetOrderByIDRow struct {
	ID           int64       `json:"id"`
	SessionID    pgtype.UUID `json:"sessionID"`
	TableID      int64       `json:"tableID"`
	TableNumber  int32       `json:"tableNumber"`
	StatusID     int64       `json:"statusID"`
	StatusName   string      `json:"statusName"`
	StatusNameEN string      `json:"statusNameEN"`
	StatusCode   string      `json:"statusCode"`
}

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (*GetOrderByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i GetOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.TableID,
		&i.TableNumber,
		&i.StatusID,
		&i.StatusName,
		&i.StatusNameEN,
		&i.StatusCode,
	)
	return &i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT o.id  AS "orderID",
       o.order_number as "orderNumber",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at,
       t.table_number as "tableNumber"
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
         JOIN public.tables t ON o.table_id = t.id
WHERE o.id = $1::bigint
order by oi.id DESC
`

type GetOrderItemsByOrderIDRow struct {
	OrderID       int64              `json:"orderID"`
	OrderNumber   string             `json:"orderNumber"`
	ID            int64              `json:"id"`
	ProductID     int64              `json:"productID"`
	ProductName   string             `json:"productName"`
	ProductNameEN string             `json:"productNameEN"`
	Quantity      int32              `json:"quantity"`
	Price         pgtype.Numeric     `json:"price"`
	StatusID      int64              `json:"statusID"`
	StatusName    string             `json:"statusName"`
	StatusNameEN  string             `json:"statusNameEN"`
	StatusCode    string             `json:"statusCode"`
	Note          pgtype.Text        `json:"note"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	TableNumber   int32              `json:"tableNumber"`
}

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID int64) ([]*GetOrderItemsByOrderIDRow, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrderItemsByOrderIDRow{}
	for rows.Next() {
		var i GetOrderItemsByOrderIDRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderNumber,
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductNameEN,
			&i.Quantity,
			&i.Price,
			&i.StatusID,
			&i.StatusName,
			&i.StatusNameEN,
			&i.StatusCode,
			&i.Note,
			&i.CreatedAt,
			&i.TableNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithItems = `-- name: GetOrderWithItems :many
SELECT o.id  AS "orderID",
       o.order_number as "orderNumber",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at,
       t.table_number as "tableNumber"
FROM public.orders o
JOIN public.order_items oi ON oi.order_id = o.id
JOIN public.md_order_statuses mos ON oi.status_id = mos.id
JOIN public.tables t ON o.table_id = t.id
WHERE o.id = $1::bigint
order by oi.id DESC
OFFSET $2 LIMIT $3
`

type GetOrderWithItemsParams struct {
	OrderID    int64 `json:"order_id"`
	Pagenumber int64 `json:"pagenumber"`
	Pagesize   int64 `json:"pagesize"`
}

type GetOrderWithItemsRow struct {
	OrderID       int64              `json:"orderID"`
	OrderNumber   string             `json:"orderNumber"`
	ID            int64              `json:"id"`
	ProductID     int64              `json:"productID"`
	ProductName   string             `json:"productName"`
	ProductNameEN string             `json:"productNameEN"`
	Quantity      int32              `json:"quantity"`
	Price         pgtype.Numeric     `json:"price"`
	StatusID      int64              `json:"statusID"`
	StatusName    string             `json:"statusName"`
	StatusNameEN  string             `json:"statusNameEN"`
	StatusCode    string             `json:"statusCode"`
	Note          pgtype.Text        `json:"note"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	TableNumber   int32              `json:"tableNumber"`
}

func (q *Queries) GetOrderWithItems(ctx context.Context, arg GetOrderWithItemsParams) ([]*GetOrderWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderWithItems, arg.OrderID, arg.Pagenumber, arg.Pagesize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrderWithItemsRow{}
	for rows.Next() {
		var i GetOrderWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderNumber,
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductNameEN,
			&i.Quantity,
			&i.Price,
			&i.StatusID,
			&i.StatusName,
			&i.StatusNameEN,
			&i.StatusCode,
			&i.Note,
			&i.CreatedAt,
			&i.TableNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithItemsByID = `-- name: GetOrderWithItemsByID :one
SELECT o.id  AS "orderID",
       o.order_number as "orderNumber",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at,
       t.table_number as "tableNumber"
FROM public.orders o
         JOIN public.tables t ON o.table_id = t.id
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
WHERE o.id = $1::bigint AND oi.id = $2::bigint LIMIT 1
`

type GetOrderWithItemsByIDParams struct {
	OrderID      int64 `json:"order_id"`
	OrderItemsID int64 `json:"order_items_id"`
}

type GetOrderWithItemsByIDRow struct {
	OrderID       int64              `json:"orderID"`
	OrderNumber   string             `json:"orderNumber"`
	ID            int64              `json:"id"`
	ProductID     int64              `json:"productID"`
	ProductName   string             `json:"productName"`
	ProductNameEN string             `json:"productNameEN"`
	Quantity      int32              `json:"quantity"`
	Price         pgtype.Numeric     `json:"price"`
	StatusID      int64              `json:"statusID"`
	StatusName    string             `json:"statusName"`
	StatusNameEN  string             `json:"statusNameEN"`
	StatusCode    string             `json:"statusCode"`
	Note          pgtype.Text        `json:"note"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	TableNumber   int32              `json:"tableNumber"`
}

func (q *Queries) GetOrderWithItemsByID(ctx context.Context, arg GetOrderWithItemsByIDParams) (*GetOrderWithItemsByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithItemsByID, arg.OrderID, arg.OrderItemsID)
	var i GetOrderWithItemsByIDRow
	err := row.Scan(
		&i.OrderID,
		&i.OrderNumber,
		&i.ID,
		&i.ProductID,
		&i.ProductName,
		&i.ProductNameEN,
		&i.Quantity,
		&i.Price,
		&i.StatusID,
		&i.StatusName,
		&i.StatusNameEN,
		&i.StatusCode,
		&i.Note,
		&i.CreatedAt,
		&i.TableNumber,
	)
	return &i, err
}

const getOrderWithItemsGroupID = `-- name: GetOrderWithItemsGroupID :many
SELECT o.id  AS "orderID",
       o.order_number as "orderNumber",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at,
       t.table_number as "tableNumber"
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
        JOIN public.tables t ON o.table_id = t.id
WHERE oi.id = ANY($1::bigint[])
order by oi.id DESC
`

type GetOrderWithItemsGroupIDRow struct {
	OrderID       int64              `json:"orderID"`
	OrderNumber   string             `json:"orderNumber"`
	ID            int64              `json:"id"`
	ProductID     int64              `json:"productID"`
	ProductName   string             `json:"productName"`
	ProductNameEN string             `json:"productNameEN"`
	Quantity      int32              `json:"quantity"`
	Price         pgtype.Numeric     `json:"price"`
	StatusID      int64              `json:"statusID"`
	StatusName    string             `json:"statusName"`
	StatusNameEN  string             `json:"statusNameEN"`
	StatusCode    string             `json:"statusCode"`
	Note          pgtype.Text        `json:"note"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	TableNumber   int32              `json:"tableNumber"`
}

func (q *Queries) GetOrderWithItemsGroupID(ctx context.Context, orderItemsID []int64) ([]*GetOrderWithItemsGroupIDRow, error) {
	rows, err := q.db.Query(ctx, getOrderWithItemsGroupID, orderItemsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrderWithItemsGroupIDRow{}
	for rows.Next() {
		var i GetOrderWithItemsGroupIDRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderNumber,
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductNameEN,
			&i.Quantity,
			&i.Price,
			&i.StatusID,
			&i.StatusName,
			&i.StatusNameEN,
			&i.StatusCode,
			&i.Note,
			&i.CreatedAt,
			&i.TableNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTableNumberOrderByID = `-- name: GetTableNumberOrderByID :one
SELECT t.table_number as "tableNumber"
FROM public.orders o
         JOIN public.tables t ON o.table_id = t.id
WHERE o.id = $1::bigint LIMIT 1
`

func (q *Queries) GetTableNumberOrderByID(ctx context.Context, orderID int64) (int32, error) {
	row := q.db.QueryRow(ctx, getTableNumberOrderByID, orderID)
	var tableNumber int32
	err := row.Scan(&tableNumber)
	return tableNumber, err
}

const getTotalItemOrderWithItems = `-- name: GetTotalItemOrderWithItems :one
SELECT COUNT(*)
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
         JOIN public.tables t ON o.table_id = t.id
WHERE o.id = $1::bigint
`

func (q *Queries) GetTotalItemOrderWithItems(ctx context.Context, orderID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalItemOrderWithItems, orderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalSearchOrderItems = `-- name: GetTotalSearchOrderItems :one
SELECT COUNT(*)
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
         JOIN public.tables t ON o.table_id = t.id
WHERE  DATE(oi.created_at) = CURRENT_DATE
  AND (($1::varchar IS NULL OR oi."product_name" ILIKE '%' || $1::varchar || '%') OR ($1::varchar IS NULL OR oi.product_name_en ILIKE '%' || $1::varchar || '%'))
  AND (
    $2::int[] IS NULL
        OR array_length($2::int[], 1) = 0
        OR t.table_number = ANY ($2::int[])
    )
  AND (
    $3::varchar[] IS NULL
        OR array_length($3::varchar[], 1) = 0
        OR mos.code = ANY ($3::varchar[])
    )
`

type GetTotalSearchOrderItemsParams struct {
	ProductName pgtype.Text `json:"product_name"`
	TableNumber []int32     `json:"table_number"`
	StatusCode  []string    `json:"status_code"`
}

func (q *Queries) GetTotalSearchOrderItems(ctx context.Context, arg GetTotalSearchOrderItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalSearchOrderItems, arg.ProductName, arg.TableNumber, arg.StatusCode)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalSearchOrderItemsIsNotFinal = `-- name: GetTotalSearchOrderItemsIsNotFinal :one
SELECT COUNT(*)
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
         JOIN public.tables t ON o.table_id = t.id
WHERE o.id = $1::bigint AND (mos.code != 'SERVED' AND mos.code != 'CANCELLED')
  AND (($2::varchar IS NULL OR oi."product_name" ILIKE '%' || $2::varchar || '%') OR ($2::varchar IS NULL OR oi.product_name_en ILIKE '%' || $2::varchar || '%'))
  AND (
    $3::varchar[] IS NULL
        OR array_length($3::varchar[], 1) = 0
        OR mos.code = ANY ($3::varchar[])
    )
`

type GetTotalSearchOrderItemsIsNotFinalParams struct {
	OrderID     int64       `json:"order_id"`
	ProductName pgtype.Text `json:"product_name"`
	StatusCode  []string    `json:"status_code"`
}

func (q *Queries) GetTotalSearchOrderItemsIsNotFinal(ctx context.Context, arg GetTotalSearchOrderItemsIsNotFinalParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalSearchOrderItemsIsNotFinal, arg.OrderID, arg.ProductName, arg.StatusCode)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isOrderExist = `-- name: IsOrderExist :one
SELECT COUNT(id) > 0 as "isExist"
FROM public.orders WHERE id = $1
`

func (q *Queries) IsOrderExist(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, isOrderExist, id)
	var isExist bool
	err := row.Scan(&isExist)
	return isExist, err
}

const isOrderItemsNotFinal = `-- name: IsOrderItemsNotFinal :one
SELECT COUNT(*) > 0 as "isNotFinal"
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
WHERE o.id = $1::bigint AND (mos.code != 'SERVED' AND mos.code != 'CANCELLED')
`

func (q *Queries) IsOrderItemsNotFinal(ctx context.Context, orderID int64) (bool, error) {
	row := q.db.QueryRow(ctx, isOrderItemsNotFinal, orderID)
	var isNotFinal bool
	err := row.Scan(&isNotFinal)
	return isNotFinal, err
}

const isOrderWithItemsExists = `-- name: IsOrderWithItemsExists :one
SELECT COUNT(*) > 0 as "isExists"
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
WHERE o.id = $1::bigint AND oi.id = $2::bigint LIMIT 1
`

type IsOrderWithItemsExistsParams struct {
	OrderID      int64 `json:"order_id"`
	OrderItemsID int64 `json:"order_items_id"`
}

func (q *Queries) IsOrderWithItemsExists(ctx context.Context, arg IsOrderWithItemsExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isOrderWithItemsExists, arg.OrderID, arg.OrderItemsID)
	var isExists bool
	err := row.Scan(&isExists)
	return isExists, err
}

const searchOrderItems = `-- name: SearchOrderItems :many
SELECT o.id  AS "orderID",
       o.order_number as "orderNumber",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       t.table_number as "tableNumber",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
         JOIN public.tables t ON o.table_id = t.id
WHERE  DATE(oi.created_at) = CURRENT_DATE
  AND (($1::varchar IS NULL OR oi."product_name" ILIKE '%' || $1::varchar || '%') OR ($1::varchar IS NULL OR oi.product_name_en ILIKE '%' || $1::varchar || '%'))
  AND (
    $2::int[] IS NULL
        OR array_length($2::int[], 1) = 0
        OR t.table_number = ANY ($2::int[])
    )
  AND (
    $3::varchar[] IS NULL
        OR array_length($3::varchar[], 1) = 0
        OR mos.code = ANY ($3::varchar[])
    )
ORDER BY CASE
             WHEN $4::text = 'asc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN oi.id::text
                     WHEN $5::text = 'tableNumber' THEN t."table_number"::text
                     WHEN $5::text = 'statusCode' THEN mos."code"::text
                     WHEN $5::text = 'productName' THEN oi."product_name"::text
                     WHEN $5::text = 'quantity' THEN oi."quantity"::text
                     ELSE oi.id::text
                     END
             END,
         CASE
             WHEN $4::text = 'desc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN oi.id::text
                     WHEN $5::text = 'tableNumber' THEN t."table_number"::text
                     WHEN $5::text = 'statusCode' THEN mos."code"::text
                     WHEN $5::text = 'productName' THEN oi."product_name"::text
                     WHEN $5::text = 'quantity' THEN oi."quantity"::text
                     ELSE oi.id::text
                     END
             END DESC
OFFSET $6 LIMIT $7
`

type SearchOrderItemsParams struct {
	ProductName pgtype.Text `json:"product_name"`
	TableNumber []int32     `json:"table_number"`
	StatusCode  []string    `json:"status_code"`
	OrderByType string      `json:"order_by_type"`
	OrderBy     string      `json:"order_by"`
	PageNumber  int64       `json:"page_number"`
	PageSize    int64       `json:"page_size"`
}

type SearchOrderItemsRow struct {
	OrderID       int64              `json:"orderID"`
	OrderNumber   string             `json:"orderNumber"`
	ID            int64              `json:"id"`
	ProductID     int64              `json:"productID"`
	ProductName   string             `json:"productName"`
	ProductNameEN string             `json:"productNameEN"`
	TableNumber   int32              `json:"tableNumber"`
	Quantity      int32              `json:"quantity"`
	Price         pgtype.Numeric     `json:"price"`
	StatusID      int64              `json:"statusID"`
	StatusName    string             `json:"statusName"`
	StatusNameEN  string             `json:"statusNameEN"`
	StatusCode    string             `json:"statusCode"`
	Note          pgtype.Text        `json:"note"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) SearchOrderItems(ctx context.Context, arg SearchOrderItemsParams) ([]*SearchOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, searchOrderItems,
		arg.ProductName,
		arg.TableNumber,
		arg.StatusCode,
		arg.OrderByType,
		arg.OrderBy,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchOrderItemsRow{}
	for rows.Next() {
		var i SearchOrderItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderNumber,
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductNameEN,
			&i.TableNumber,
			&i.Quantity,
			&i.Price,
			&i.StatusID,
			&i.StatusName,
			&i.StatusNameEN,
			&i.StatusCode,
			&i.Note,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOrderItemsIsNotFinal = `-- name: SearchOrderItemsIsNotFinal :many
SELECT o.id  AS "orderID",
       o.order_number as "orderNumber",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       t.table_number as "tableNumber",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
         JOIN public.tables t ON o.table_id = t.id
WHERE o.id = $1::bigint AND (mos.code != 'SERVED' AND mos.code != 'CANCELLED')
  AND (($2::varchar IS NULL OR oi."product_name" ILIKE '%' || $2::varchar || '%') OR ($2::varchar IS NULL OR oi.product_name_en ILIKE '%' || $2::varchar || '%'))
  AND (
    $3::varchar[] IS NULL
        OR array_length($3::varchar[], 1) = 0
        OR mos.code = ANY ($3::varchar[])
    )
ORDER BY CASE
             WHEN $4::text = 'asc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN oi.id::text
                     WHEN $5::text = 'statusCode' THEN mos."code"::text
                     WHEN $5::text = 'productName' THEN oi."product_name"::text
                     WHEN $5::text = 'quantity' THEN oi."quantity"::text
                     ELSE oi.id::text
                     END
             END,
         CASE
             WHEN $4::text = 'desc' THEN
                 CASE
                     WHEN $5::text = 'id' THEN oi.id::text
                     WHEN $5::text = 'statusCode' THEN mos."code"::text
                     WHEN $5::text = 'productName' THEN oi."product_name"::text
                     WHEN $5::text = 'quantity' THEN oi."quantity"::text
                     ELSE oi.id::text
                     END
             END DESC
OFFSET $6 LIMIT $7
`

type SearchOrderItemsIsNotFinalParams struct {
	OrderID     int64       `json:"order_id"`
	ProductName pgtype.Text `json:"product_name"`
	StatusCode  []string    `json:"status_code"`
	OrderByType string      `json:"order_by_type"`
	OrderBy     string      `json:"order_by"`
	PageNumber  int64       `json:"page_number"`
	PageSize    int64       `json:"page_size"`
}

type SearchOrderItemsIsNotFinalRow struct {
	OrderID       int64              `json:"orderID"`
	OrderNumber   string             `json:"orderNumber"`
	ID            int64              `json:"id"`
	ProductID     int64              `json:"productID"`
	ProductName   string             `json:"productName"`
	ProductNameEN string             `json:"productNameEN"`
	TableNumber   int32              `json:"tableNumber"`
	Quantity      int32              `json:"quantity"`
	Price         pgtype.Numeric     `json:"price"`
	StatusID      int64              `json:"statusID"`
	StatusName    string             `json:"statusName"`
	StatusNameEN  string             `json:"statusNameEN"`
	StatusCode    string             `json:"statusCode"`
	Note          pgtype.Text        `json:"note"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) SearchOrderItemsIsNotFinal(ctx context.Context, arg SearchOrderItemsIsNotFinalParams) ([]*SearchOrderItemsIsNotFinalRow, error) {
	rows, err := q.db.Query(ctx, searchOrderItemsIsNotFinal,
		arg.OrderID,
		arg.ProductName,
		arg.StatusCode,
		arg.OrderByType,
		arg.OrderBy,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchOrderItemsIsNotFinalRow{}
	for rows.Next() {
		var i SearchOrderItemsIsNotFinalRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderNumber,
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductNameEN,
			&i.TableNumber,
			&i.Quantity,
			&i.Price,
			&i.StatusID,
			&i.StatusName,
			&i.StatusNameEN,
			&i.StatusCode,
			&i.Note,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE public.orders
SET status_id = (SELECT id FROM public.md_order_statuses WHERE code = $1::text LIMIT 1)
WHERE id = $2::bigint
`

type UpdateOrderStatusParams struct {
	StatusCode string `json:"status_code"`
	ID         int64  `json:"id"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.StatusCode, arg.ID)
	return err
}

const updateOrderStatusCompletedAndAmount = `-- name: UpdateOrderStatusCompletedAndAmount :exec
UPDATE public.orders
SET total_amount =$1::numeric, status_id = (SELECT id FROM public.md_order_statuses WHERE code = 'COMPLETED' LIMIT 1)
WHERE id = $2::bigint
`

type UpdateOrderStatusCompletedAndAmountParams struct {
	Amount pgtype.Numeric `json:"amount"`
	ID     int64          `json:"id"`
}

func (q *Queries) UpdateOrderStatusCompletedAndAmount(ctx context.Context, arg UpdateOrderStatusCompletedAndAmountParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatusCompletedAndAmount, arg.Amount, arg.ID)
	return err
}

const updateOrderStatusWaitForPayment = `-- name: UpdateOrderStatusWaitForPayment :exec
UPDATE public.orders
SET status_id = (SELECT id FROM public.md_order_statuses WHERE code = 'WAITING_PAYMENT' LIMIT 1)
WHERE id = $1::bigint
`

func (q *Queries) UpdateOrderStatusWaitForPayment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateOrderStatusWaitForPayment, id)
	return err
}
