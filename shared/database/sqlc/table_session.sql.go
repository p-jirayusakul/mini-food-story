// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: table_session.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTableSession = `-- name: CreateTableSession :exec
INSERT INTO public.table_session
(id, table_id, number_of_people, session_id, status, started_at, expires_at, ended_at)
VALUES($1, $2, $3, $4, 'active', NOW(), $5, NULL)
`

type CreateTableSessionParams struct {
	ID             int64              `json:"id"`
	TableID        int64              `json:"table_id"`
	NumberOfPeople int32              `json:"number_of_people"`
	SessionID      pgtype.UUID        `json:"session_id"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateTableSession(ctx context.Context, arg CreateTableSessionParams) error {
	_, err := q.db.Exec(ctx, createTableSession,
		arg.ID,
		arg.TableID,
		arg.NumberOfPeople,
		arg.SessionID,
		arg.ExpiresAt,
	)
	return err
}

const getExpiresAtByTableID = `-- name: GetExpiresAtByTableID :one
select expires_at, max_extend_minutes, extend_total_minutes from public.table_session where table_id = $1::bigint LIMIT 1
`

type GetExpiresAtByTableIDRow struct {
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	MaxExtendMinutes   int32              `json:"max_extend_minutes"`
	ExtendTotalMinutes int32              `json:"extend_total_minutes"`
}

func (q *Queries) GetExpiresAtByTableID(ctx context.Context, tableID int64) (*GetExpiresAtByTableIDRow, error) {
	row := q.db.QueryRow(ctx, getExpiresAtByTableID, tableID)
	var i GetExpiresAtByTableIDRow
	err := row.Scan(&i.ExpiresAt, &i.MaxExtendMinutes, &i.ExtendTotalMinutes)
	return &i, err
}

const getSessionIDByTableID = `-- name: GetSessionIDByTableID :one
select session_id from public.table_session where table_id = $1::bigint and status = 'active' LIMIT 1
`

func (q *Queries) GetSessionIDByTableID(ctx context.Context, tableID int64) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getSessionIDByTableID, tableID)
	var session_id pgtype.UUID
	err := row.Scan(&session_id)
	return session_id, err
}

const getTableSession = `-- name: GetTableSession :one
SELECT ts.session_id as "sessionID",
       t.id          AS "tableID",
       t.table_number      as "tableNumber",
       ts.status           as "status",
       ts.started_at       as "startedAt",
       o.id                AS "orderID"
FROM public.table_session ts
         JOIN public.tables t ON t.id = ts.table_id
         LEFT JOIN public.orders o ON o.session_id = ts.session_id
WHERE ts.session_id = $1::uuid
`

type GetTableSessionRow struct {
	SessionID   pgtype.UUID            `json:"sessionID"`
	TableID     int64                  `json:"tableID"`
	TableNumber int32                  `json:"tableNumber"`
	Status      NullTableSessionStatus `json:"status"`
	StartedAt   pgtype.Timestamptz     `json:"startedAt"`
	OrderID     pgtype.Int8            `json:"orderID"`
}

func (q *Queries) GetTableSession(ctx context.Context, sessionid pgtype.UUID) (*GetTableSessionRow, error) {
	row := q.db.QueryRow(ctx, getTableSession, sessionid)
	var i GetTableSessionRow
	err := row.Scan(
		&i.SessionID,
		&i.TableID,
		&i.TableNumber,
		&i.Status,
		&i.StartedAt,
		&i.OrderID,
	)
	return &i, err
}

const isTableSessionActive = `-- name: IsTableSessionActive :one
SELECT COUNT(session_id) > 0 as "isExists"
FROM public.table_session
WHERE session_id = $1::uuid
  AND status = 'active'
`

func (q *Queries) IsTableSessionActive(ctx context.Context, sessionid pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isTableSessionActive, sessionid)
	var isExists bool
	err := row.Scan(&isExists)
	return isExists, err
}

const isTableSessionExists = `-- name: IsTableSessionExists :one
SELECT COUNT(session_id) > 0 as "isExists"
FROM public.table_session
WHERE session_id = $1::uuid
`

func (q *Queries) IsTableSessionExists(ctx context.Context, sessionid pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isTableSessionExists, sessionid)
	var isExists bool
	err := row.Scan(&isExists)
	return isExists, err
}

const updateSessionExpireBySessionID = `-- name: UpdateSessionExpireBySessionID :exec
UPDATE public.table_session
SET extend_count =  extend_count + 1,
    extend_total_minutes = extend_total_minutes + $1::integer,
    last_reason_code = $2::text,
    lock_version = lock_version + 1,
    expires_at = $3::timestamp with time zone
where session_id=$4::uuid
`

type UpdateSessionExpireBySessionIDParams struct {
	RequestedMinutes int32              `json:"requested_minutes"`
	LastReasonCode   string             `json:"last_reason_code"`
	ExpiresAt        pgtype.Timestamptz `json:"expires_at"`
	Sessionid        pgtype.UUID        `json:"sessionid"`
}

func (q *Queries) UpdateSessionExpireBySessionID(ctx context.Context, arg UpdateSessionExpireBySessionIDParams) error {
	_, err := q.db.Exec(ctx, updateSessionExpireBySessionID,
		arg.RequestedMinutes,
		arg.LastReasonCode,
		arg.ExpiresAt,
		arg.Sessionid,
	)
	return err
}

const updateStatusCloseTableSession = `-- name: UpdateStatusCloseTableSession :exec
UPDATE public.table_session
SET ended_at=NOW(), status='closed'
WHERE session_id=$1::uuid
`

func (q *Queries) UpdateStatusCloseTableSession(ctx context.Context, sessionid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateStatusCloseTableSession, sessionid)
	return err
}
